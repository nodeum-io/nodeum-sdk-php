<?php
/**
 * FilesApi
 * PHP version 5
 *
 * @category Class
 * @package  NodeumSDK\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Nodeum API
 *
 * The Nodeum API makes it easy to tap into the digital data mesh that runs across your organisation. Make requests to our API endpoints and we’ll give you everything you need to interconnect your business workflows with your storage.  All production API requests are made to:  http://nodeumhostname/api/  The current production version of the API is v1.   **REST** The Nodeum API is a RESTful API. This means that the API is designed to allow you to get, create, update, & delete objects with the HTTP verbs GET, POST, PUT, PATCH, & DELETE.  **JSON** The Nodeum API speaks exclusively in JSON. This means that you should always set the Content-Type header to application/json to ensure that your requests are properly accepted and processed by the API.  **Authentication** All API calls require user-password authentication.   **Cross-Origin Resource Sharing** The Nodeum API supports CORS for communicating from Javascript for these endpoints. You will need to specify an Origin URI when creating your application to allow for CORS to be whitelisted for your domain.   **Pagination** Some endpoints such as File Listing return a potentially lengthy array of objects. In order to keep the response sizes manageable the API will take advantage of pagination. Pagination is a mechanism for returning a subset of the results for a request and allowing for subsequent requests to “page” through the rest of the results until the end is reached. Paginated endpoints follow a standard interface that accepts two query parameters, limit and offset, and return a payload that follows a standard form. These parameters names and their behavior are borrowed from SQL LIMIT and OFFSET keywords.  **Versioning** The Nodeum API is constantly being worked on to add features, make improvements, and fix bugs. This means that you should expect changes to be introduced and documented.   However, there are some changes or additions that are considered backwards-compatible and your applications should be flexible enough to handle them. These include:  - Adding new endpoints to the API - Adding new attributes to the response of an existing endpoint - Changing the order of attributes of responses (JSON by definition is an object of unordered key/value pairs)  **Filter parameters** When browsing a list of items, multiple filter parameters may be applied. Some operators can be added to the value as a prefix:  - `=` value is equal. Default operator, may be omitted  - `!=` value is different  - `>` greater than  - `>=` greater than or equal  - `<` lower than  - `>=` lower than or equal  - `><` included in list, items should be separated by `|`  - `!><` not included in list, items should be separated by `|`  - `~` pattern matching, may include `%` (any characters) and `_` (one character)  - `!~` pattern not matching, may include `%` (any characters) and `_` (one character)
 *
 * The version of the OpenAPI document: 2.1.0
 * Contact: info@nodeum.io
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace NodeumSDK\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use NodeumSDK\Client\ApiException;
use NodeumSDK\Client\Configuration;
use NodeumSDK\Client\HeaderSelector;
use NodeumSDK\Client\ObjectSerializer;

/**
 * FilesApi Class Doc Comment
 *
 * @category Class
 * @package  NodeumSDK\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FilesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation filesChildren
     *
     * Lists files under a specific folder.
     *
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function filesChildren($file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->filesChildrenWithHttpInfo($file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation filesChildrenWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function filesChildrenWithHttpInfo($file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->filesChildrenRequest($file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filesChildrenAsync
     *
     * Lists files under a specific folder.
     *
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenAsync($file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->filesChildrenAsyncWithHttpInfo($file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filesChildrenAsyncWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenAsyncWithHttpInfo($file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->filesChildrenRequest($file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filesChildren'
     *
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function filesChildrenRequest($file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'file_parent_id' is set
        if ($file_parent_id === null || (is_array($file_parent_id) && count($file_parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_parent_id when calling filesChildren'
            );
        }

        $resourcePath = '/files/{file_parent_id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($file_parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_parent_id' . '}',
                ObjectSerializer::toPathValue($file_parent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filesChildrenByContainer
     *
     * Lists files under a specific folder.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function filesChildrenByContainer($container_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->filesChildrenByContainerWithHttpInfo($container_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation filesChildrenByContainerWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function filesChildrenByContainerWithHttpInfo($container_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->filesChildrenByContainerRequest($container_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filesChildrenByContainerAsync
     *
     * Lists files under a specific folder.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByContainerAsync($container_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->filesChildrenByContainerAsyncWithHttpInfo($container_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filesChildrenByContainerAsyncWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByContainerAsyncWithHttpInfo($container_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->filesChildrenByContainerRequest($container_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filesChildrenByContainer'
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function filesChildrenByContainerRequest($container_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'container_id' is set
        if ($container_id === null || (is_array($container_id) && count($container_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container_id when calling filesChildrenByContainer'
            );
        }
        // verify the required parameter 'file_parent_id' is set
        if ($file_parent_id === null || (is_array($file_parent_id) && count($file_parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_parent_id when calling filesChildrenByContainer'
            );
        }

        $resourcePath = '/containers/{container_id}/files/{file_parent_id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($container_id !== null) {
            $resourcePath = str_replace(
                '{' . 'container_id' . '}',
                ObjectSerializer::toPathValue($container_id),
                $resourcePath
            );
        }
        // path params
        if ($file_parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_parent_id' . '}',
                ObjectSerializer::toPathValue($file_parent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filesChildrenByPool
     *
     * Lists files under a specific folder.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function filesChildrenByPool($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->filesChildrenByPoolWithHttpInfo($pool_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation filesChildrenByPoolWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function filesChildrenByPoolWithHttpInfo($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->filesChildrenByPoolRequest($pool_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filesChildrenByPoolAsync
     *
     * Lists files under a specific folder.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByPoolAsync($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->filesChildrenByPoolAsyncWithHttpInfo($pool_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filesChildrenByPoolAsyncWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByPoolAsyncWithHttpInfo($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->filesChildrenByPoolRequest($pool_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filesChildrenByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function filesChildrenByPoolRequest($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling filesChildrenByPool'
            );
        }
        // verify the required parameter 'file_parent_id' is set
        if ($file_parent_id === null || (is_array($file_parent_id) && count($file_parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_parent_id when calling filesChildrenByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/files/{file_parent_id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }
        // path params
        if ($file_parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_parent_id' . '}',
                ObjectSerializer::toPathValue($file_parent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filesChildrenByTask
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function filesChildrenByTask($task_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->filesChildrenByTaskWithHttpInfo($task_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation filesChildrenByTaskWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function filesChildrenByTaskWithHttpInfo($task_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->filesChildrenByTaskRequest($task_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filesChildrenByTaskAsync
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByTaskAsync($task_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->filesChildrenByTaskAsyncWithHttpInfo($task_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filesChildrenByTaskAsyncWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByTaskAsyncWithHttpInfo($task_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->filesChildrenByTaskRequest($task_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filesChildrenByTask'
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function filesChildrenByTaskRequest($task_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling filesChildrenByTask'
            );
        }
        // verify the required parameter 'file_parent_id' is set
        if ($file_parent_id === null || (is_array($file_parent_id) && count($file_parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_parent_id when calling filesChildrenByTask'
            );
        }

        $resourcePath = '/tasks/{task_id}/files/{file_parent_id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_id' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($file_parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_parent_id' . '}',
                ObjectSerializer::toPathValue($file_parent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filesChildrenByTaskExecution
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function filesChildrenByTaskExecution($task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->filesChildrenByTaskExecutionWithHttpInfo($task_execution_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation filesChildrenByTaskExecutionWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function filesChildrenByTaskExecutionWithHttpInfo($task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->filesChildrenByTaskExecutionRequest($task_execution_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filesChildrenByTaskExecutionAsync
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByTaskExecutionAsync($task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->filesChildrenByTaskExecutionAsyncWithHttpInfo($task_execution_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filesChildrenByTaskExecutionAsyncWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByTaskExecutionAsyncWithHttpInfo($task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->filesChildrenByTaskExecutionRequest($task_execution_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filesChildrenByTaskExecution'
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function filesChildrenByTaskExecutionRequest($task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'task_execution_id' is set
        if ($task_execution_id === null || (is_array($task_execution_id) && count($task_execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_execution_id when calling filesChildrenByTaskExecution'
            );
        }
        // verify the required parameter 'file_parent_id' is set
        if ($file_parent_id === null || (is_array($file_parent_id) && count($file_parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_parent_id when calling filesChildrenByTaskExecution'
            );
        }

        $resourcePath = '/task_executions/{task_execution_id}/files/{file_parent_id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($task_execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_execution_id' . '}',
                ObjectSerializer::toPathValue($task_execution_id),
                $resourcePath
            );
        }
        // path params
        if ($file_parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_parent_id' . '}',
                ObjectSerializer::toPathValue($file_parent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filesChildrenByTaskExecutionByTask
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function filesChildrenByTaskExecutionByTask($task_id, $task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->filesChildrenByTaskExecutionByTaskWithHttpInfo($task_id, $task_execution_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation filesChildrenByTaskExecutionByTaskWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function filesChildrenByTaskExecutionByTaskWithHttpInfo($task_id, $task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->filesChildrenByTaskExecutionByTaskRequest($task_id, $task_execution_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filesChildrenByTaskExecutionByTaskAsync
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByTaskExecutionByTaskAsync($task_id, $task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->filesChildrenByTaskExecutionByTaskAsyncWithHttpInfo($task_id, $task_execution_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filesChildrenByTaskExecutionByTaskAsyncWithHttpInfo
     *
     * Lists files under a specific folder.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filesChildrenByTaskExecutionByTaskAsyncWithHttpInfo($task_id, $task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->filesChildrenByTaskExecutionByTaskRequest($task_id, $task_execution_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filesChildrenByTaskExecutionByTask'
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function filesChildrenByTaskExecutionByTaskRequest($task_id, $task_execution_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling filesChildrenByTaskExecutionByTask'
            );
        }
        // verify the required parameter 'task_execution_id' is set
        if ($task_execution_id === null || (is_array($task_execution_id) && count($task_execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_execution_id when calling filesChildrenByTaskExecutionByTask'
            );
        }
        // verify the required parameter 'file_parent_id' is set
        if ($file_parent_id === null || (is_array($file_parent_id) && count($file_parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_parent_id when calling filesChildrenByTaskExecutionByTask'
            );
        }

        $resourcePath = '/tasks/{task_id}/task_executions/{task_execution_id}/files/{file_parent_id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_id' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($task_execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_execution_id' . '}',
                ObjectSerializer::toPathValue($task_execution_id),
                $resourcePath
            );
        }
        // path params
        if ($file_parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_parent_id' . '}',
                ObjectSerializer::toPathValue($file_parent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importFilesChildrenByPool
     *
     * Lists files under a specific folder on tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\ImportFileCollection
     */
    public function importFilesChildrenByPool($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->importFilesChildrenByPoolWithHttpInfo($pool_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation importFilesChildrenByPoolWithHttpInfo
     *
     * Lists files under a specific folder on tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\ImportFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function importFilesChildrenByPoolWithHttpInfo($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->importFilesChildrenByPoolRequest($pool_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\ImportFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\ImportFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\ImportFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\ImportFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importFilesChildrenByPoolAsync
     *
     * Lists files under a specific folder on tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importFilesChildrenByPoolAsync($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->importFilesChildrenByPoolAsyncWithHttpInfo($pool_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importFilesChildrenByPoolAsyncWithHttpInfo
     *
     * Lists files under a specific folder on tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importFilesChildrenByPoolAsyncWithHttpInfo($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\ImportFileCollection';
        $request = $this->importFilesChildrenByPoolRequest($pool_id, $file_parent_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importFilesChildrenByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function importFilesChildrenByPoolRequest($pool_id, $file_parent_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling importFilesChildrenByPool'
            );
        }
        // verify the required parameter 'file_parent_id' is set
        if ($file_parent_id === null || (is_array($file_parent_id) && count($file_parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_parent_id when calling importFilesChildrenByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/import_files/{file_parent_id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }
        // path params
        if ($file_parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_parent_id' . '}',
                ObjectSerializer::toPathValue($file_parent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexFiles
     *
     * Lists files on root.
     *
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function indexFiles($limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->indexFilesWithHttpInfo($limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation indexFilesWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexFilesWithHttpInfo($limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->indexFilesRequest($limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexFilesAsync
     *
     * Lists files on root.
     *
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesAsync($limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->indexFilesAsyncWithHttpInfo($limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexFilesAsyncWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesAsyncWithHttpInfo($limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->indexFilesRequest($limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexFiles'
     *
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexFilesRequest($limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {

        $resourcePath = '/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexFilesByContainer
     *
     * Lists files on root.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function indexFilesByContainer($container_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->indexFilesByContainerWithHttpInfo($container_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation indexFilesByContainerWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexFilesByContainerWithHttpInfo($container_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->indexFilesByContainerRequest($container_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexFilesByContainerAsync
     *
     * Lists files on root.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByContainerAsync($container_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->indexFilesByContainerAsyncWithHttpInfo($container_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexFilesByContainerAsyncWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByContainerAsyncWithHttpInfo($container_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->indexFilesByContainerRequest($container_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexFilesByContainer'
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexFilesByContainerRequest($container_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'container_id' is set
        if ($container_id === null || (is_array($container_id) && count($container_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container_id when calling indexFilesByContainer'
            );
        }

        $resourcePath = '/containers/{container_id}/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($container_id !== null) {
            $resourcePath = str_replace(
                '{' . 'container_id' . '}',
                ObjectSerializer::toPathValue($container_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexFilesByPool
     *
     * Lists files on root.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function indexFilesByPool($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->indexFilesByPoolWithHttpInfo($pool_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation indexFilesByPoolWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexFilesByPoolWithHttpInfo($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->indexFilesByPoolRequest($pool_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexFilesByPoolAsync
     *
     * Lists files on root.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByPoolAsync($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->indexFilesByPoolAsyncWithHttpInfo($pool_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexFilesByPoolAsyncWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByPoolAsyncWithHttpInfo($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->indexFilesByPoolRequest($pool_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexFilesByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexFilesByPoolRequest($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling indexFilesByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexFilesByTask
     *
     * Lists files on root.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function indexFilesByTask($task_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->indexFilesByTaskWithHttpInfo($task_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation indexFilesByTaskWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexFilesByTaskWithHttpInfo($task_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->indexFilesByTaskRequest($task_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexFilesByTaskAsync
     *
     * Lists files on root.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByTaskAsync($task_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->indexFilesByTaskAsyncWithHttpInfo($task_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexFilesByTaskAsyncWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByTaskAsyncWithHttpInfo($task_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->indexFilesByTaskRequest($task_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexFilesByTask'
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexFilesByTaskRequest($task_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling indexFilesByTask'
            );
        }

        $resourcePath = '/tasks/{task_id}/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_id' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexFilesByTaskExecution
     *
     * Lists files on root.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function indexFilesByTaskExecution($task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->indexFilesByTaskExecutionWithHttpInfo($task_execution_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation indexFilesByTaskExecutionWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexFilesByTaskExecutionWithHttpInfo($task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->indexFilesByTaskExecutionRequest($task_execution_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexFilesByTaskExecutionAsync
     *
     * Lists files on root.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByTaskExecutionAsync($task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->indexFilesByTaskExecutionAsyncWithHttpInfo($task_execution_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexFilesByTaskExecutionAsyncWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByTaskExecutionAsyncWithHttpInfo($task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->indexFilesByTaskExecutionRequest($task_execution_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexFilesByTaskExecution'
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexFilesByTaskExecutionRequest($task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'task_execution_id' is set
        if ($task_execution_id === null || (is_array($task_execution_id) && count($task_execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_execution_id when calling indexFilesByTaskExecution'
            );
        }

        $resourcePath = '/task_executions/{task_execution_id}/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($task_execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_execution_id' . '}',
                ObjectSerializer::toPathValue($task_execution_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexFilesByTaskExecutionByTask
     *
     * Lists files on root.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileCollection
     */
    public function indexFilesByTaskExecutionByTask($task_id, $task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->indexFilesByTaskExecutionByTaskWithHttpInfo($task_id, $task_execution_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation indexFilesByTaskExecutionByTaskWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexFilesByTaskExecutionByTaskWithHttpInfo($task_id, $task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->indexFilesByTaskExecutionByTaskRequest($task_id, $task_execution_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexFilesByTaskExecutionByTaskAsync
     *
     * Lists files on root.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByTaskExecutionByTaskAsync($task_id, $task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->indexFilesByTaskExecutionByTaskAsyncWithHttpInfo($task_id, $task_execution_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexFilesByTaskExecutionByTaskAsyncWithHttpInfo
     *
     * Lists files on root.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexFilesByTaskExecutionByTaskAsyncWithHttpInfo($task_id, $task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileCollection';
        $request = $this->indexFilesByTaskExecutionByTaskRequest($task_id, $task_execution_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexFilesByTaskExecutionByTask'
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexFilesByTaskExecutionByTaskRequest($task_id, $task_execution_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling indexFilesByTaskExecutionByTask'
            );
        }
        // verify the required parameter 'task_execution_id' is set
        if ($task_execution_id === null || (is_array($task_execution_id) && count($task_execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_execution_id when calling indexFilesByTaskExecutionByTask'
            );
        }

        $resourcePath = '/tasks/{task_id}/task_executions/{task_execution_id}/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_id' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($task_execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_execution_id' . '}',
                ObjectSerializer::toPathValue($task_execution_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexImportFilesByPool
     *
     * Lists files on root of tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\ImportFileCollection
     */
    public function indexImportFilesByPool($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        list($response) = $this->indexImportFilesByPoolWithHttpInfo($pool_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);
        return $response;
    }

    /**
     * Operation indexImportFilesByPoolWithHttpInfo
     *
     * Lists files on root of tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\ImportFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexImportFilesByPoolWithHttpInfo($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $request = $this->indexImportFilesByPoolRequest($pool_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\ImportFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\ImportFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\ImportFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\ImportFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexImportFilesByPoolAsync
     *
     * Lists files on root of tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexImportFilesByPoolAsync($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        return $this->indexImportFilesByPoolAsyncWithHttpInfo($pool_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexImportFilesByPoolAsyncWithHttpInfo
     *
     * Lists files on root of tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexImportFilesByPoolAsyncWithHttpInfo($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        $returnType = '\NodeumSDK\Client\Model\ImportFileCollection';
        $request = $this->indexImportFilesByPoolRequest($pool_id, $limit, $offset, $file_id, $name, $type, $permission, $size, $change_date, $modification_date, $access_date, $gid, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexImportFilesByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $file_id Filter on file id (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $permission Filter on permission (optional)
     * @param  string $size Filter on size (optional)
     * @param  string $change_date Filter on change date (optional)
     * @param  string $modification_date Filter on modification date (optional)
     * @param  string $access_date Filter on access date (optional)
     * @param  string $gid Filter on gid (optional)
     * @param  string $uid Filter on uid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexImportFilesByPoolRequest($pool_id, $limit = null, $offset = null, $file_id = null, $name = null, $type = null, $permission = null, $size = null, $change_date = null, $modification_date = null, $access_date = null, $gid = null, $uid = null)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling indexImportFilesByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/import_files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($file_id)) {
            $file_id = ObjectSerializer::serializeCollection($file_id, '', true);
        }
        if ($file_id !== null) {
            $queryParams['file_id'] = $file_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($permission)) {
            $permission = ObjectSerializer::serializeCollection($permission, '', true);
        }
        if ($permission !== null) {
            $queryParams['permission'] = $permission;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }
        // query params
        if (is_array($change_date)) {
            $change_date = ObjectSerializer::serializeCollection($change_date, '', true);
        }
        if ($change_date !== null) {
            $queryParams['change_date'] = $change_date;
        }
        // query params
        if (is_array($modification_date)) {
            $modification_date = ObjectSerializer::serializeCollection($modification_date, '', true);
        }
        if ($modification_date !== null) {
            $queryParams['modification_date'] = $modification_date;
        }
        // query params
        if (is_array($access_date)) {
            $access_date = ObjectSerializer::serializeCollection($access_date, '', true);
        }
        if ($access_date !== null) {
            $queryParams['access_date'] = $access_date;
        }
        // query params
        if (is_array($gid)) {
            $gid = ObjectSerializer::serializeCollection($gid, '', true);
        }
        if ($gid !== null) {
            $queryParams['gid'] = $gid;
        }
        // query params
        if (is_array($uid)) {
            $uid = ObjectSerializer::serializeCollection($uid, '', true);
        }
        if ($uid !== null) {
            $queryParams['uid'] = $uid;
        }


        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexOnTapesFilesByPool
     *
     * Lists files on root of tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\OnTapesFileCollection
     */
    public function indexOnTapesFilesByPool($pool_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        list($response) = $this->indexOnTapesFilesByPoolWithHttpInfo($pool_id, $limit, $offset, $name, $type, $size);
        return $response;
    }

    /**
     * Operation indexOnTapesFilesByPoolWithHttpInfo
     *
     * Lists files on root of tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\OnTapesFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexOnTapesFilesByPoolWithHttpInfo($pool_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        $request = $this->indexOnTapesFilesByPoolRequest($pool_id, $limit, $offset, $name, $type, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\OnTapesFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\OnTapesFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\OnTapesFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\OnTapesFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexOnTapesFilesByPoolAsync
     *
     * Lists files on root of tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexOnTapesFilesByPoolAsync($pool_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        return $this->indexOnTapesFilesByPoolAsyncWithHttpInfo($pool_id, $limit, $offset, $name, $type, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexOnTapesFilesByPoolAsyncWithHttpInfo
     *
     * Lists files on root of tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexOnTapesFilesByPoolAsyncWithHttpInfo($pool_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        $returnType = '\NodeumSDK\Client\Model\OnTapesFileCollection';
        $request = $this->indexOnTapesFilesByPoolRequest($pool_id, $limit, $offset, $name, $type, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexOnTapesFilesByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexOnTapesFilesByPoolRequest($pool_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling indexOnTapesFilesByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/on_tapes_files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }


        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexTapesByFileByPool
     *
     * Displays tapes containing specific file, related to the specific pool.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\TapeCollection
     */
    public function indexTapesByFileByPool($pool_id, $file_id)
    {
        list($response) = $this->indexTapesByFileByPoolWithHttpInfo($pool_id, $file_id);
        return $response;
    }

    /**
     * Operation indexTapesByFileByPoolWithHttpInfo
     *
     * Displays tapes containing specific file, related to the specific pool.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\TapeCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexTapesByFileByPoolWithHttpInfo($pool_id, $file_id)
    {
        $request = $this->indexTapesByFileByPoolRequest($pool_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\TapeCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\TapeCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\TapeCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\TapeCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexTapesByFileByPoolAsync
     *
     * Displays tapes containing specific file, related to the specific pool.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexTapesByFileByPoolAsync($pool_id, $file_id)
    {
        return $this->indexTapesByFileByPoolAsyncWithHttpInfo($pool_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexTapesByFileByPoolAsyncWithHttpInfo
     *
     * Displays tapes containing specific file, related to the specific pool.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexTapesByFileByPoolAsyncWithHttpInfo($pool_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\TapeCollection';
        $request = $this->indexTapesByFileByPoolRequest($pool_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexTapesByFileByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexTapesByFileByPoolRequest($pool_id, $file_id)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling indexTapesByFileByPool'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling indexTapesByFileByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/files/{file_id}/tapes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexTapesByFileByTask
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\TapeCollection
     */
    public function indexTapesByFileByTask($task_id, $file_id)
    {
        list($response) = $this->indexTapesByFileByTaskWithHttpInfo($task_id, $file_id);
        return $response;
    }

    /**
     * Operation indexTapesByFileByTaskWithHttpInfo
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\TapeCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexTapesByFileByTaskWithHttpInfo($task_id, $file_id)
    {
        $request = $this->indexTapesByFileByTaskRequest($task_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\TapeCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\TapeCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\TapeCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\TapeCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexTapesByFileByTaskAsync
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexTapesByFileByTaskAsync($task_id, $file_id)
    {
        return $this->indexTapesByFileByTaskAsyncWithHttpInfo($task_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexTapesByFileByTaskAsyncWithHttpInfo
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexTapesByFileByTaskAsyncWithHttpInfo($task_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\TapeCollection';
        $request = $this->indexTapesByFileByTaskRequest($task_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexTapesByFileByTask'
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexTapesByFileByTaskRequest($task_id, $file_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling indexTapesByFileByTask'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling indexTapesByFileByTask'
            );
        }

        $resourcePath = '/tasks/{task_id}/files/{file_id}/tapes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_id' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexTapesByFileByTaskExecution
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\TapeCollection
     */
    public function indexTapesByFileByTaskExecution($task_execution_id, $file_id)
    {
        list($response) = $this->indexTapesByFileByTaskExecutionWithHttpInfo($task_execution_id, $file_id);
        return $response;
    }

    /**
     * Operation indexTapesByFileByTaskExecutionWithHttpInfo
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\TapeCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexTapesByFileByTaskExecutionWithHttpInfo($task_execution_id, $file_id)
    {
        $request = $this->indexTapesByFileByTaskExecutionRequest($task_execution_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\TapeCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\TapeCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\TapeCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\TapeCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexTapesByFileByTaskExecutionAsync
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexTapesByFileByTaskExecutionAsync($task_execution_id, $file_id)
    {
        return $this->indexTapesByFileByTaskExecutionAsyncWithHttpInfo($task_execution_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexTapesByFileByTaskExecutionAsyncWithHttpInfo
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexTapesByFileByTaskExecutionAsyncWithHttpInfo($task_execution_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\TapeCollection';
        $request = $this->indexTapesByFileByTaskExecutionRequest($task_execution_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexTapesByFileByTaskExecution'
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexTapesByFileByTaskExecutionRequest($task_execution_id, $file_id)
    {
        // verify the required parameter 'task_execution_id' is set
        if ($task_execution_id === null || (is_array($task_execution_id) && count($task_execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_execution_id when calling indexTapesByFileByTaskExecution'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling indexTapesByFileByTaskExecution'
            );
        }

        $resourcePath = '/task_executions/{task_execution_id}/files/{file_id}/tapes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_execution_id' . '}',
                ObjectSerializer::toPathValue($task_execution_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexTapesByFileByTaskExecutionByTask
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\TapeCollection
     */
    public function indexTapesByFileByTaskExecutionByTask($task_id, $task_execution_id, $file_id)
    {
        list($response) = $this->indexTapesByFileByTaskExecutionByTaskWithHttpInfo($task_id, $task_execution_id, $file_id);
        return $response;
    }

    /**
     * Operation indexTapesByFileByTaskExecutionByTaskWithHttpInfo
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\TapeCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function indexTapesByFileByTaskExecutionByTaskWithHttpInfo($task_id, $task_execution_id, $file_id)
    {
        $request = $this->indexTapesByFileByTaskExecutionByTaskRequest($task_id, $task_execution_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\TapeCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\TapeCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\TapeCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\TapeCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indexTapesByFileByTaskExecutionByTaskAsync
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexTapesByFileByTaskExecutionByTaskAsync($task_id, $task_execution_id, $file_id)
    {
        return $this->indexTapesByFileByTaskExecutionByTaskAsyncWithHttpInfo($task_id, $task_execution_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indexTapesByFileByTaskExecutionByTaskAsyncWithHttpInfo
     *
     * Displays tapes containing specific file, related to the specific task.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indexTapesByFileByTaskExecutionByTaskAsyncWithHttpInfo($task_id, $task_execution_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\TapeCollection';
        $request = $this->indexTapesByFileByTaskExecutionByTaskRequest($task_id, $task_execution_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indexTapesByFileByTaskExecutionByTask'
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function indexTapesByFileByTaskExecutionByTaskRequest($task_id, $task_execution_id, $file_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling indexTapesByFileByTaskExecutionByTask'
            );
        }
        // verify the required parameter 'task_execution_id' is set
        if ($task_execution_id === null || (is_array($task_execution_id) && count($task_execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_execution_id when calling indexTapesByFileByTaskExecutionByTask'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling indexTapesByFileByTaskExecutionByTask'
            );
        }

        $resourcePath = '/tasks/{task_id}/task_executions/{task_execution_id}/files/{file_id}/tapes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_id' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($task_execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_execution_id' . '}',
                ObjectSerializer::toPathValue($task_execution_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation onTapesFilesChildrenByPool
     *
     * Lists files under a specific folder on tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\OnTapesFileCollection
     */
    public function onTapesFilesChildrenByPool($pool_id, $file_parent_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        list($response) = $this->onTapesFilesChildrenByPoolWithHttpInfo($pool_id, $file_parent_id, $limit, $offset, $name, $type, $size);
        return $response;
    }

    /**
     * Operation onTapesFilesChildrenByPoolWithHttpInfo
     *
     * Lists files under a specific folder on tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\OnTapesFileCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function onTapesFilesChildrenByPoolWithHttpInfo($pool_id, $file_parent_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        $request = $this->onTapesFilesChildrenByPoolRequest($pool_id, $file_parent_id, $limit, $offset, $name, $type, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\OnTapesFileCollection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\OnTapesFileCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\OnTapesFileCollection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\OnTapesFileCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation onTapesFilesChildrenByPoolAsync
     *
     * Lists files under a specific folder on tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function onTapesFilesChildrenByPoolAsync($pool_id, $file_parent_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        return $this->onTapesFilesChildrenByPoolAsyncWithHttpInfo($pool_id, $file_parent_id, $limit, $offset, $name, $type, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation onTapesFilesChildrenByPoolAsyncWithHttpInfo
     *
     * Lists files under a specific folder on tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function onTapesFilesChildrenByPoolAsyncWithHttpInfo($pool_id, $file_parent_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        $returnType = '\NodeumSDK\Client\Model\OnTapesFileCollection';
        $request = $this->onTapesFilesChildrenByPoolRequest($pool_id, $file_parent_id, $limit, $offset, $name, $type, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'onTapesFilesChildrenByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_parent_id Numeric ID of parent folder. (required)
     * @param  int $limit The number of items to display for pagination. (optional)
     * @param  int $offset The number of items to skip for pagination. (optional)
     * @param  string $name Filter on name (optional)
     * @param  string $type Filter on type (optional)
     * @param  string $size Filter on size (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function onTapesFilesChildrenByPoolRequest($pool_id, $file_parent_id, $limit = null, $offset = null, $name = null, $type = null, $size = null)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling onTapesFilesChildrenByPool'
            );
        }
        // verify the required parameter 'file_parent_id' is set
        if ($file_parent_id === null || (is_array($file_parent_id) && count($file_parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_parent_id when calling onTapesFilesChildrenByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/on_tapes_files/{file_parent_id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($size)) {
            $size = ObjectSerializer::serializeCollection($size, '', true);
        }
        if ($size !== null) {
            $queryParams['size'] = $size;
        }


        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }
        // path params
        if ($file_parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_parent_id' . '}',
                ObjectSerializer::toPathValue($file_parent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showFile
     *
     * Displays a specific file.
     *
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileWithPath
     */
    public function showFile($file_id)
    {
        list($response) = $this->showFileWithHttpInfo($file_id);
        return $response;
    }

    /**
     * Operation showFileWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileWithPath, HTTP status code, HTTP response headers (array of strings)
     */
    public function showFileWithHttpInfo($file_id)
    {
        $request = $this->showFileRequest($file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileWithPath' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileWithPath', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileWithPath',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showFileAsync
     *
     * Displays a specific file.
     *
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileAsync($file_id)
    {
        return $this->showFileAsyncWithHttpInfo($file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showFileAsyncWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileAsyncWithHttpInfo($file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
        $request = $this->showFileRequest($file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showFile'
     *
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function showFileRequest($file_id)
    {
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling showFile'
            );
        }

        $resourcePath = '/files/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showFileByContainer
     *
     * Displays a specific file.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileWithPath
     */
    public function showFileByContainer($container_id, $file_id)
    {
        list($response) = $this->showFileByContainerWithHttpInfo($container_id, $file_id);
        return $response;
    }

    /**
     * Operation showFileByContainerWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileWithPath, HTTP status code, HTTP response headers (array of strings)
     */
    public function showFileByContainerWithHttpInfo($container_id, $file_id)
    {
        $request = $this->showFileByContainerRequest($container_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileWithPath' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileWithPath', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileWithPath',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showFileByContainerAsync
     *
     * Displays a specific file.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByContainerAsync($container_id, $file_id)
    {
        return $this->showFileByContainerAsyncWithHttpInfo($container_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showFileByContainerAsyncWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByContainerAsyncWithHttpInfo($container_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
        $request = $this->showFileByContainerRequest($container_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showFileByContainer'
     *
     * @param  string $container_id Numeric ID or name of container. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function showFileByContainerRequest($container_id, $file_id)
    {
        // verify the required parameter 'container_id' is set
        if ($container_id === null || (is_array($container_id) && count($container_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container_id when calling showFileByContainer'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling showFileByContainer'
            );
        }

        $resourcePath = '/containers/{container_id}/files/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($container_id !== null) {
            $resourcePath = str_replace(
                '{' . 'container_id' . '}',
                ObjectSerializer::toPathValue($container_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showFileByPool
     *
     * Displays a specific file.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileWithPath
     */
    public function showFileByPool($pool_id, $file_id)
    {
        list($response) = $this->showFileByPoolWithHttpInfo($pool_id, $file_id);
        return $response;
    }

    /**
     * Operation showFileByPoolWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileWithPath, HTTP status code, HTTP response headers (array of strings)
     */
    public function showFileByPoolWithHttpInfo($pool_id, $file_id)
    {
        $request = $this->showFileByPoolRequest($pool_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileWithPath' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileWithPath', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileWithPath',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showFileByPoolAsync
     *
     * Displays a specific file.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByPoolAsync($pool_id, $file_id)
    {
        return $this->showFileByPoolAsyncWithHttpInfo($pool_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showFileByPoolAsyncWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByPoolAsyncWithHttpInfo($pool_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
        $request = $this->showFileByPoolRequest($pool_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showFileByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function showFileByPoolRequest($pool_id, $file_id)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling showFileByPool'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling showFileByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/files/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showFileByTask
     *
     * Displays a specific file.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileWithPath
     */
    public function showFileByTask($task_id, $file_id)
    {
        list($response) = $this->showFileByTaskWithHttpInfo($task_id, $file_id);
        return $response;
    }

    /**
     * Operation showFileByTaskWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileWithPath, HTTP status code, HTTP response headers (array of strings)
     */
    public function showFileByTaskWithHttpInfo($task_id, $file_id)
    {
        $request = $this->showFileByTaskRequest($task_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileWithPath' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileWithPath', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileWithPath',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showFileByTaskAsync
     *
     * Displays a specific file.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByTaskAsync($task_id, $file_id)
    {
        return $this->showFileByTaskAsyncWithHttpInfo($task_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showFileByTaskAsyncWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByTaskAsyncWithHttpInfo($task_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
        $request = $this->showFileByTaskRequest($task_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showFileByTask'
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function showFileByTaskRequest($task_id, $file_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling showFileByTask'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling showFileByTask'
            );
        }

        $resourcePath = '/tasks/{task_id}/files/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_id' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showFileByTaskExecution
     *
     * Displays a specific file.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileWithPath
     */
    public function showFileByTaskExecution($task_execution_id, $file_id)
    {
        list($response) = $this->showFileByTaskExecutionWithHttpInfo($task_execution_id, $file_id);
        return $response;
    }

    /**
     * Operation showFileByTaskExecutionWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileWithPath, HTTP status code, HTTP response headers (array of strings)
     */
    public function showFileByTaskExecutionWithHttpInfo($task_execution_id, $file_id)
    {
        $request = $this->showFileByTaskExecutionRequest($task_execution_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileWithPath' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileWithPath', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileWithPath',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showFileByTaskExecutionAsync
     *
     * Displays a specific file.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByTaskExecutionAsync($task_execution_id, $file_id)
    {
        return $this->showFileByTaskExecutionAsyncWithHttpInfo($task_execution_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showFileByTaskExecutionAsyncWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByTaskExecutionAsyncWithHttpInfo($task_execution_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
        $request = $this->showFileByTaskExecutionRequest($task_execution_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showFileByTaskExecution'
     *
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function showFileByTaskExecutionRequest($task_execution_id, $file_id)
    {
        // verify the required parameter 'task_execution_id' is set
        if ($task_execution_id === null || (is_array($task_execution_id) && count($task_execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_execution_id when calling showFileByTaskExecution'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling showFileByTaskExecution'
            );
        }

        $resourcePath = '/task_executions/{task_execution_id}/files/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_execution_id' . '}',
                ObjectSerializer::toPathValue($task_execution_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showFileByTaskExecutionByTask
     *
     * Displays a specific file.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\NodeumFileWithPath
     */
    public function showFileByTaskExecutionByTask($task_id, $task_execution_id, $file_id)
    {
        list($response) = $this->showFileByTaskExecutionByTaskWithHttpInfo($task_id, $task_execution_id, $file_id);
        return $response;
    }

    /**
     * Operation showFileByTaskExecutionByTaskWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\NodeumFileWithPath, HTTP status code, HTTP response headers (array of strings)
     */
    public function showFileByTaskExecutionByTaskWithHttpInfo($task_id, $task_execution_id, $file_id)
    {
        $request = $this->showFileByTaskExecutionByTaskRequest($task_id, $task_execution_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\NodeumFileWithPath' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\NodeumFileWithPath', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\NodeumFileWithPath',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showFileByTaskExecutionByTaskAsync
     *
     * Displays a specific file.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByTaskExecutionByTaskAsync($task_id, $task_execution_id, $file_id)
    {
        return $this->showFileByTaskExecutionByTaskAsyncWithHttpInfo($task_id, $task_execution_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showFileByTaskExecutionByTaskAsyncWithHttpInfo
     *
     * Displays a specific file.
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFileByTaskExecutionByTaskAsyncWithHttpInfo($task_id, $task_execution_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\NodeumFileWithPath';
        $request = $this->showFileByTaskExecutionByTaskRequest($task_id, $task_execution_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showFileByTaskExecutionByTask'
     *
     * @param  string $task_id Numeric ID or name of task. Task names are not unique, it&#39;s recommanded to use numeric ID. (required)
     * @param  string $task_execution_id Numeric ID of task execution. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function showFileByTaskExecutionByTaskRequest($task_id, $task_execution_id, $file_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling showFileByTaskExecutionByTask'
            );
        }
        // verify the required parameter 'task_execution_id' is set
        if ($task_execution_id === null || (is_array($task_execution_id) && count($task_execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_execution_id when calling showFileByTaskExecutionByTask'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling showFileByTaskExecutionByTask'
            );
        }

        $resourcePath = '/tasks/{task_id}/task_executions/{task_execution_id}/files/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_id' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($task_execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_execution_id' . '}',
                ObjectSerializer::toPathValue($task_execution_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showImportFileByPool
     *
     * Displays a specific file on tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\ImportFileWithPath
     */
    public function showImportFileByPool($pool_id, $file_id)
    {
        list($response) = $this->showImportFileByPoolWithHttpInfo($pool_id, $file_id);
        return $response;
    }

    /**
     * Operation showImportFileByPoolWithHttpInfo
     *
     * Displays a specific file on tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\ImportFileWithPath, HTTP status code, HTTP response headers (array of strings)
     */
    public function showImportFileByPoolWithHttpInfo($pool_id, $file_id)
    {
        $request = $this->showImportFileByPoolRequest($pool_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\ImportFileWithPath' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\ImportFileWithPath', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\ImportFileWithPath';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\ImportFileWithPath',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showImportFileByPoolAsync
     *
     * Displays a specific file on tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showImportFileByPoolAsync($pool_id, $file_id)
    {
        return $this->showImportFileByPoolAsyncWithHttpInfo($pool_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showImportFileByPoolAsyncWithHttpInfo
     *
     * Displays a specific file on tape of pools, specific for Data Exchange.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showImportFileByPoolAsyncWithHttpInfo($pool_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\ImportFileWithPath';
        $request = $this->showImportFileByPoolRequest($pool_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showImportFileByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function showImportFileByPoolRequest($pool_id, $file_id)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling showImportFileByPool'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling showImportFileByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/import_files/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showOnTapeFileByPool
     *
     * Displays a specific file on tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NodeumSDK\Client\Model\OnTapesFile
     */
    public function showOnTapeFileByPool($pool_id, $file_id)
    {
        list($response) = $this->showOnTapeFileByPoolWithHttpInfo($pool_id, $file_id);
        return $response;
    }

    /**
     * Operation showOnTapeFileByPoolWithHttpInfo
     *
     * Displays a specific file on tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \NodeumSDK\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NodeumSDK\Client\Model\OnTapesFile, HTTP status code, HTTP response headers (array of strings)
     */
    public function showOnTapeFileByPoolWithHttpInfo($pool_id, $file_id)
    {
        $request = $this->showOnTapeFileByPoolRequest($pool_id, $file_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\NodeumSDK\Client\Model\OnTapesFile' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\NodeumSDK\Client\Model\OnTapesFile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\NodeumSDK\Client\Model\OnTapesFile';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NodeumSDK\Client\Model\OnTapesFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showOnTapeFileByPoolAsync
     *
     * Displays a specific file on tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showOnTapeFileByPoolAsync($pool_id, $file_id)
    {
        return $this->showOnTapeFileByPoolAsyncWithHttpInfo($pool_id, $file_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showOnTapeFileByPoolAsyncWithHttpInfo
     *
     * Displays a specific file on tape of pools, specific for Active and Offline.
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showOnTapeFileByPoolAsyncWithHttpInfo($pool_id, $file_id)
    {
        $returnType = '\NodeumSDK\Client\Model\OnTapesFile';
        $request = $this->showOnTapeFileByPoolRequest($pool_id, $file_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showOnTapeFileByPool'
     *
     * @param  string $pool_id Numeric ID, or name of pool. (required)
     * @param  int $file_id Numeric ID of file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function showOnTapeFileByPoolRequest($pool_id, $file_id)
    {
        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling showOnTapeFileByPool'
            );
        }
        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling showOnTapeFileByPool'
            );
        }

        $resourcePath = '/pools/{pool_id}/on_tapes_files/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
